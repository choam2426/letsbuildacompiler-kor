[English](./TUTORIAL.md) | 한국어

이 문서는 원본
["Let's Build a Compiler"](https://compilers.iecc.com/crenshaw/) 튜토리얼이
**WASM 텍스트를 출력하는 Python 기반 컴파일러**로 어떻게 옮겨졌는지(번역/이식) 설명합니다.
가장 좋은 따라가기 방법은 Part 1부터 시작해 아래 순서를 반복하는 것입니다:

1. 원 튜토리얼의 Part N을 읽습니다.
2. 이 문서의 Part N 섹션을 읽습니다.
3. `partN_<name>.py` 코드와 `tests` 디렉터리의 대응 테스트를 함께 확인합니다.

## Part 1: Introduction

이 파트는 “Cradle(요람)”의 번역이며, 우리 컴파일러의 기본 구조입니다.
전역 변수를 사용하는 대신 `Compiler` 클래스를 정의합니다. 생성자는 입력 소스 코드와
어셈블리(여기서는 WASM 텍스트)를 출력할 스트림을 받습니다. 이는 원 튜토리얼의 `Init`
함수가 하던 일을 수행하는데, 파서를 “시동(priming)”하기 위해 `get_char`를 호출합니다.

그 외에는 Python의 내장 기능 때문에 생기는 작은 차이들이 있습니다:

* `IsAlpha`/`IsDigit`를 구현할 필요가 없습니다. `str.isalpha`, `str.isdigit`가 이미 있습니다.
* `Error`/`Abort`를 따로 둘 필요가 없습니다. `abort`에서 Python 예외를 발생시키면 됩니다.

## Part 2: Expression Parsing

이 파트는 한 자리 숫자로 구성된 아주 단순한 산술 표현식을 위한 첫 번째 “진짜 컴파일러”입니다.
우리 코드는 튜토리얼의 최종 버전(중첩 계산을 위해 스택을 사용하는 버전)과 맞춰져 있습니다.

스택을 사용하는 방식은 WASM에 매우 자연스럽습니다. WASM은 스택 기반 머신이기 때문입니다.
`expression`, `subtract`, `term` 같은 각 컴파일러 메서드는 결과를 TOS(top of stack)에
단 하나의 32비트 정수로 남깁니다. 예를 들어 `2+3*4`는 다음과 같이 컴파일됩니다:

```
  i32.const 2
  i32.const 3
  i32.const 4
  i32.mul
  i32.add
```

이 파트의 테스트(`tests/test_02_expression_parsing.py`)에는 완전한 테스트 하네스가 포함되어 있습니다.
단 하나의 "main" 함수를 가진 WASM 모듈을 구성하고, 그 안에 컴파일된 표현식을 출력한 다음,
`wasmtime-py` 바인딩으로 실행해 결과를 얻습니다. 이 결과를 기대값과 비교할 수 있습니다.

## Part 3: More Expressions

이 파트는 공백을 올바르게 처리하고, 여러 자리 숫자 및 여러 문자로 된 변수 이름을 지원하도록 컴파일러를 확장합니다.
다만 이 파트의 컴파일러는 다소 불완전합니다. 부작용이 없는 단 하나의 대입문만 처리하기 때문입니다.
인자 없는 함수 호출도 지원하지만, 실제 함수 정의와의 링킹 없이 호출만 출력합니다. 이런 부분은 이후 파트에서 다룹니다.

우리 번역은 원 튜토리얼의 Pascal 코드에 매우 충실하며, WASM 구문으로 대응시켰습니다.
예를 들어 `foo = 42` 대입의 경우 다음과 같이 출력합니다:

```
  (local $FOO i32)
  i32.const 42
  local.set $FOO
```

함수 호출 `foo()`는 다음과 같이 출력합니다:

```
  call $foo
```

하지만 실제로는 어디에도 해당 함수가 정의되어 있지 않습니다. 따라서 이 파트의 테스트는 아무것도 실행하지 않고,
생성된 WASM 텍스트에 대한 간단한 검증만 수행합니다. 이후 파트에서는 여기서 구현된 기반 위에 더 많은 기능이 올라가므로,
자동 실행 테스트에 더 적합해질 것입니다.

## Part 4: Interpreters

이 파트는 약간의 우회로로, 코드를 출력(emission)하는 대신 즉석에서 표현식을 평가해야 할 때
파서 구조가 얼마나(조금) 달라지는지 보여 줍니다. 이 목표에 맞추어, 이 파트의 메인 클래스는 `Compiler`가 아니라
`Interpreter`라고 부릅니다.

입력(?)과 출력(!) 연산을 지원하기 위해 `Interpreter`는 입력/출력 스트림을 매개변수로 받습니다
(실행되는 프로그램의 "stdin"/"stdout"). `Compiler`와 달리 출력 스트림에 코드를 내보내지 않으며,
그 스트림으로 나가는 유일한 출력은 `!` 연산에서 발생합니다.

그 외에는 여느 때처럼 우리 인터프리터 구조는 원 튜토리얼을 매우 가깝게 따릅니다.
약간의 개선도 있습니다. 예를 들어 단일 문자 변수만이 아니라 임의 길이 변수 이름을 위한 더 일반적인 변수 테이블을 사용합니다.
또한 원 튜토리얼에는 재귀 하강(recursive-descent) 호출의 중첩을 제대로 구현하지 않은 버그가 있는데,
예를 들어 `Term`에서 `Factor` 대신 `GetNum`으로 시작합니다. 이러면 괄호가 있는 중첩 표현식이 지원되지 않습니다.
우리 `Interpreter`는 이런 문제들을 포함해 몇 가지 유사한 이슈를 수정합니다.

## Part 5: Control Constructs

이 파트는 또 다른 우회로로, 제어 구조를 파싱하고 코드를 출력하는 방법을 다룹니다.
파서는 다시 단일 문자 토큰을 받아들이므로, 프런트엔드는 실험 용도로만 유용합니다. 입력 예시는 다음과 같습니다:

```
wixbyeze
```

의미는 다음과 같습니다:

```
while <condition>
  if <condition>
    x
    break
    y
  else
    z
  end
end
```

이 파트에서는 조건/표현식 등을 실제로 파싱하거나 출력하는 부분 같은 많은 것들이 생략되어 있습니다.
대신 다양한 종류의 루프를 올바르게 출력하는 방법에 초점을 맞춥니다.

우리 코드는 이를 WASM의 루프 구문으로 가깝게 옮겼습니다. 기본 WASM 루프 구조는 다음과 같습니다:

```
loop $looplabel
  block $breaklooplabel
    # branching to $breaklooplabel exits the loop
    # branching to $looplabel continues to the next iteration    
  end
end
```

`IF...THEN...ELSE`의 경우는 더 단순합니다. WASM은 다음 같은 블록을 직접 지원합니다:

```
if
  # code
else
  # code
end
```

따라서 다양한 조건문과 루프 구성, 그리고 BREAK 문까지 모두 구현할 수 있습니다.

이 파트가 보여 주는 또 다른 까다로운 이슈는 로컬 변수 관리입니다.
WASM은 블록 밖에서 스택에 값을 쌓아 두고 블록 안에서 접근하는 것을 허용하지 않습니다.
따라서 (DO, FOR처럼) 루프 변수가 필요한 루프마다 루프 변수를 담을 local을 생성합니다.
FOR의 경우 루프 한계값을 위한 local도 하나 더 생성합니다.

원 튜토리얼에는 몇 가지 버그도 있습니다(예: 특정 표현식 출력을 빠뜨리거나 FOR 루프에서 TO 매칭을 잊는 등).
Jack Crenshaw가 이 파트에서 생성된 코드를 실제로 실행해 보지 않았던 것으로 보이며,
이 파트는 이후 파트를 위한 준비에 가깝습니다. 여기서는 본격적인 실행 테스트 대신 텍스트 출력에 대한 건전성(sanity) 체크만 합니다.

## Part 6: Boolean Expressions

이 파트는 불리언 표현식(예: '>' 비교)을 추가하고, 이를 전체 표현식 파싱 구조에 통합합니다.
표현식의 BNF를 Python 구현으로 그대로 옮깁니다(원 튜토리얼에서 몇 번의 반복을 거쳐 정리되는 최종 BNF).
그리고 코드를 컴파일러에 통합합니다.

또한 이 파트는 5장에서 도입된 제어 구조와 표현식 파싱을 하나로 합칩니다.
토큰은 여전히 단일 문자로 제한되지만, 이제는 실제 프로그래밍과 조금 닮은 코드를 작성할 수 있습니다:

```
Y = 3
X = 0
w Y > 3
  X = X + 2
  Y = Y - 1
e
```

이 파트에서는 (2장처럼 `wasmtime-py`를 이용한) 완전한 실행 테스트로 돌아가는 것이 중요했습니다.
출력되는 코드가 점점 더 복잡해지고 있기 때문에, 유효하고 올바르게 동작하는 코드를 출력하고 있는지 확인하려면
전체 테스트가 필수입니다.

이를 위해 테스트 하네스에 몇 가지 조치를 추가해야 했습니다. 구체적으로, 모든 프로그램에 대해 몇 개의 로컬 변수를 선언합니다:

```
(local $X i32)
(local $Y i32)
(local $Z i32)
(local $loopvar1 i32)
(local $looplimit1 i32)
```

`$loopvar1`과 `$looplimit1`은 단 하나의 출력된 FOR 루프에 사용됩니다. `X`, `Y`, `Z`는 입력 코드에서 사용할 변수 이름들입니다.
튜토리얼이 다루는 언어에는 아직 변수 선언이라는 개념이 없고, WASM은 함수 상단에서 locals를 미리 선언해야 하므로,
테스트 하네스에서 이 부분을 임시로 처리했습니다. 이후 파트에서 변수 선언과 프로시저가 다뤄지면,
이런 해킹은 필요 없어질 것으로 기대합니다.

마지막으로, 원 튜토리얼의 몇몇 버그를 우리 코드에서는 회피합니다. 예를 들어 튜토리얼의 `Factor` 프로시저는
`Match('(')` 이후에 `Expression`이 아니라 `BoolExpression`을 호출해야 합니다
(튜토리얼에 제시된 BNF는 맞지만, 코드가 틀립니다).

또한 원 튜토리얼에서는 FOR 루프에서 `TO`를 매칭하지 않는데(아마 단일 문자가 아니기 때문),
우리도 이를 그대로 생략합니다.

마지막으로, 원 튜토리얼은 줄바꿈으로 "문장(statement)"을 구분하기 위해 `Fin`을 정의합니다.
우리는 이를 약간 다르게 처리하는데, `get_char`를 호출할 때마다 `skip_white`를 호출합니다.
결과적으로 어떤 공백이든 문장 사이를 구분할 수 있습니다.

## Part 7: Lexical Scanning

원 튜토리얼은 토큰 표현 방식에 대해 여러 번 왔다 갔다 하다가, 최종 코드는 단일 문자를 사용합니다.
저는 (원 튜토리얼에도 설명된) 더 전통적인 enum 기반 접근을 선택했습니다.
개인적으로 단일 문자 토큰 종류는 읽기 어렵습니다(특히 중복될 때 — 원 튜토리얼에서는 'e'가 END와 ENDIF를 모두 뜻합니다).

또한 Pascal에는 내장 해시 테이블이 없기 때문에 키워드 조회가 꽤 번잡하고 비효율적입니다.
`Lookup` 함수는 호출될 때마다 선형 탐색을 수행합니다.

우리 Python 구현에서는 토큰을 다음과 같이 표현합니다:

```python
@dataclass
class Token:
    kind: TokenKind
    value: str

class TokenKind(Enum):
    ADD = auto()
    SUB = auto()
    MUL = auto()
    DIV = auto()
    # ... more kinds
```

다음 토큰을 스캔하는 단일 메서드 `advance_scanner`가 있고, 토큰 사이의 모든 공백을 건너뛰는 역할도 함께 합니다.
그리고 원 튜토리얼처럼 파싱 코드는 크게 변하지 않는데, 달라진 점은 다음뿐입니다:

* `get_char` 대신 `advance_scanner` 사용
* 파서가 어떤 토큰을 보고 있는지 판단할 때 `self.look` 대신 `self.token.kind`를 사용

또 하나의 설계 결정은, 키워드를 각각의 전용 토큰으로 두지 않고 모두 `NAME` 토큰으로 표현하는 것입니다.
이렇게 하면 매칭이 아주 약간 장황해지지만, 원 튜토리얼처럼 키워드가 예상되지 않는 위치(예: 변수명)에서도 사용할 수 있게 됩니다.

원 튜토리얼 코드에는 우리가 재현하지 않도록 주의한 여러 문제가 있습니다:

* `DoIf`가 IF 토큰('i')을 소비하지 않고 `Block`을 호출합니다. 그러면 `Block`은 같은 토큰을 보고 다시 `DoIf`를 호출해
  무한 재귀에 빠질 수 있습니다. 우리 `do_if`는 시작하자마자 `self.advance_scanner`를 호출해 IF 토큰을 소비합니다.
* `GetNum`은 "숫자"를 '#'로 표현하지만 어디에서도 쓰이지 않고, 또한 "같지 않음" 연산자('#')와 충돌합니다.
  우리 코드는 숫자를 `NUMBER` 토큰 종류로 표현합니다(스캔 방식은 `advance_scanner` 참고).

이 파트의 우리 코드는 지금까지 다룬 언어의 거의 전부를 구현합니다. 다만 코드 양을 줄이기 위해 몇 가지 루프 종류만 제외했습니다.
IF 문, 대입문, 모든 표현식(불리언/산술), REPEAT...UNTIL 루프를 지원합니다.
추가 루프를 지원하는 것은 매우 쉽습니다. Part 6의 `do_...` 메서드를 가져와 토큰 기반으로 조정하면 됩니다.

## Part 8: A Little Philosophy

원 튜토리얼의 이 파트에는 코드가 없습니다.

## Part 9: A Top View

이 파트는 이전 파트와 동일한 접근으로 “전체 언어”용 컴파일러를 만드는 방법을 시연합니다.
다시 단일 문자 토큰으로 돌아가며, 대부분은 적절한 중첩 구조로 서로를 호출하는 스캐폴딩(scaffolding) 함수를 만드는 내용입니다.

우리 버전은 설명된 단순화된 Pascal 파싱을 구현합니다. 실제로 “무언가를 하지는” 않지만,
재귀 하강 파서가 탑다운(top-down)으로 어떻게 계획되는지 보여 주는 좋은 연습입니다.

또한 이전 파트에서 놓쳤던 중요한 주제 하나를 다룹니다: prolog/epilog를 포함한 완전한 출력 구조를 만드는 것입니다.
우리의 경우 이는 단순히 WASM 모듈 블록을 출력하는 것입니다:

```python
def prolog(self, name: str):
    self.emit_ln(f"; Module {name}")
    self.emit_ln("(module")

def epilog(self):
    self.emit_ln(")")
```

이전에는 (표현식이나 문장 시퀀스 같은 작은 코드 조각에 집중했기 때문에) 파서 안에 자연스러운 위치가 없어
테스트 하네스에서 이 작업을 해야 했습니다. 이 파트에서는 프로그램 전체를 컴파일하는 최상위 `prog` 메서드가 생기므로,
prolog + epilog 호출을 포함하기에 자연스러운 위치가 됩니다.

## Part 10: Introducing "Tiny"

이 파트는 이전 파트의 학습을 모두 결합해 TINY라는 작은 언어를 만듭니다.
단일 문자 버전으로 시작한 뒤, 7장의 렉서(scanner)를 도입해 여러 문자 토큰을 지원하도록 발전합니다.
다만 키워드는 여전히 단일 문자(`i`=IF, `w`=WHILE 등)를 유지합니다.

우리 코드에서는 단일 문자 버전을 커밋 히스토리에서 찾을 수 있고, 최종 코드는 렉서를 포함해
여러 문자 연산자 및 변수 이름을 지원합니다.

TINY는 이전 시도보다 더 완전한 환경이므로, 변수 선언과 사용이 어떻게 이어지는지 마침내 한데 묶을 수 있습니다.
TINY에서 변수 선언(`v` 뒤의 이름들)은 WASM의 `$global` 선언으로 번역되며, 모든 변수는 글로벌로 매핑됩니다.
일반적으로 우리가 출력하는 WASM 모듈의 스캐폴딩은 다음과 같습니다:

```
(module
  (func $read_i32 (import "" "read_i32") (result i32))
  (func $write_i32 (import "" "write_i32") (param i32))
  (global $X (mut i32) (i32.const 8))
  ;; ... more globals
  (func $main (export "main") (result i32)
    ;; ... code
    global.get $X  ;; implicit return of $X, for testing
  )
)
```

TINY 코드에서 `y` 같은 변수를 참조하면 글로벌 조회(`global.get $Y`)나 대입(`global.set $Y`)으로 번역됩니다.

TINY는 IO도 지원합니다. stdin에서 변수를 읽고 stdout으로 출력할 수 있습니다.
WASM은 호스트 환경에 임베딩되는 것을 전제로 설계되어 있으므로, 우리는 특별한 `read_i32`, `write_i32` 함수를 import해서 처리합니다.
이 함수들은 테스트 하네스가 제공하므로, IO 처리는 호스트 Python 코드만 담당하면 됩니다
(대안으로 WASI를 사용해 WASM에서 직접 IO를 할 수도 있지만, 코드가 훨씬 많아지고 유연성도 떨어질 것입니다).

우리 코드는 IO 함수로 `R`/`W` 대신 `read`/`write`를 사용하므로, 코드는 다음처럼 보입니다:

```
  p
      v x,y,z
  b
      read(x, y)
      z = x + y
      write(z, x * 2, y * 3)
  e.
```

## Part 11: Lexical Scan Revisited

이 파트에서 저자는 여러 제한을 해결하기 위해 TINY의 렉서를 수정합니다.

Part 7에서 내린 선택이 여기서 매우 잘 맞아떨어집니다. 우리의 스캐너는 이미 올바른 구조로 되어 있어 변경이 필요 없습니다.
`advance_scanner`는 원 튜토리얼의 `Next`와 정확히 같은 역할을 합니다. 먼저 공백을 건너뛰고, 줄바꿈을 특별 취급하지 않는 등
동일한 동작을 합니다.

이제 파싱 메서드도 같은 형태로 보입니다. 예:

```python
def add(self):
    self.advance_scanner()
    self.term()
    self.emit_ln("i32.add")
```

`block` 같은 메서드도 더 잘 맞습니다. 우리의 스캐너는 `self.token`에 완전한 `Token`을 넣어 두기 때문에,
`block`은 어떤 종류의 문장인지 식별하기 전에 추가로 무언가를 소비할 필요가 없습니다.

따라서 이 파트에서는 코드가 필요 없습니다. 원 튜토리얼은 `PROGRAM` 키워드(정확히는 `p`)를 제거하는 등 약간의 수정을 했지만,
우리 part 10의 500줄짜리 컴파일러를 다시 복사할 만큼의 변화는 아닙니다.

## Part 12: Miscellany

이 파트는 세미콜론과 주석을 구현하는 몇 가지 선택지를 논의한 뒤, 다음 결정을 내립니다:

1. 세미콜론은 구분자(separator)가 아니라 종결자(terminator)다
2. 세미콜론은 선택(optional)이다
3. 주석은 중괄호로 감싼다
4. 주석은 중첩될 수 있다

우리 구현은 이를 따르며, 스캐너 구조에 맞춘 약간의 조정이 있습니다.
세미콜론이 어차피 선택이므로, 블록 안의 *각* 문장 끝에서 세미콜론을 허용합니다. 이것이 구현하기 훨씬 단순합니다.
원 튜토리얼처럼 `statement`를 별도 메서드로 분리했기 때문에, 우리 `block`은 다음처럼 단순합니다:

```python
def block(self, breakloop_label: str = ""):
    while self.token.kind != TokenKind.EOF:
        if self.statement(breakloop_label):
            break
        self.semi()
```

그리고 `statement`는 세미콜론을 전혀 다루지 않습니다. `statement`가 별도 메서드가 되었기 때문에,
끝 키워드(`E` 또는 `L`)를 만나면 `True`를 반환해 `block`이 종료해야 함을 알립니다.

주석은 원 튜토리얼과 정확히 같은 방식으로 `skip_white`에서 구현됩니다(다른 메서드는 변경할 필요가 없습니다).
`part10_introducing_tiny.py`와 `part12_miscellany.py`를 diff해 보면 어떤 변경이 필요한지 교육적으로 확인할 수 있습니다.

## Part 13: Procedures

이 파트는 기능과 복잡도가 크게 점프합니다. 값 전달(by-value)과 참조 전달(by-reference) 매개변수를 가진 프로시저를 추가하기 때문입니다.
이제 우리가 다루는 것은 실제 프로그래밍 언어에 가까워집니다:

```
procedure divmod(dividend, divisor, ref quotient, ref remainder)
    quotient = dividend / divisor
    remainder = dividend - (quotient * divisor)
end
```

(여러 문자 토큰을 지원합니다.)

원 튜토리얼은 매개변수를 값/참조로 전달하는 방식 사이를 오가는데, 저는 최대한의 유연성을 위해 둘 다 지원하기로 했습니다.
매개변수 선언에서 `ref` 접두 토큰이 있으면 참조 전달(by-ref)이고, 그렇지 않으면 값 전달(by-value)입니다.

참조 전달이 동작하도록 하기 위해, 우리는 [WASM Basic C ABI](https://eli.thegreenplace.net/2025/notes-on-the-wasm-basic-c-abi/)에서처럼
WASM의 선형 메모리 스택(linear stack)을 활용합니다. 변수를 선형 메모리에 복사하고, 그 주소를 함수에 전달합니다.
함수는 이런 변수를 접근할 때 `i32.load`, `i32.store`로 메모리와 상호작용합니다.

위의 `divmod` 프로시저에 대해 출력되는 WASM은 다음과 같습니다:

```
(func $DIVMOD (param $DIVIDEND i32) (param $DIVISOR i32) (param $QUOTIENT i32) (param $REMAINDER i32)
  local.get $QUOTIENT
  local.get $DIVIDEND
  local.get $DIVISOR
  i32.div_s
  i32.store
  local.get $REMAINDER
  local.get $DIVIDEND
  local.get $QUOTIENT
  i32.load
  local.get $DIVISOR
  i32.mul
  i32.sub
  i32.store
)
```

이제 우리 컴파일러에는 심볼 테이블(symbol table)이 있어서 로컬 변수/글로벌 변수/프로시저를 구분하고,
로컬 변수가 참조 전달인지 값 전달인지도 표시합니다. 원 튜토리얼처럼 로컬 변수도 지원합니다.
심볼 테이블에는 부모 링크가 있어, C 같은 언어에서 흔한 “글로벌을 로컬이 가리는(shadowing)” 것도 지원합니다.
나중에 원 튜토리얼이 타입을 설명할 때, 이 심볼 테이블은 변수에 타입 정보를 추가하는 방향으로 자연스럽게 확장할 수 있습니다.
또한 같은 인프라를 사용해 렉시컬 스코프도 쉽게 지원할 수 있습니다.

또한 이것은 프로시저가 사용되기 전에 정의되어야 함을 뜻합니다. 호출 지점은 프로시저의 매개변수, 개수, 참조 전달 여부를 알아야 하기 때문입니다.
이는 많은 프로그래밍 언어의 일반적인 제약이며, 이후에는 다중 패스 컴파일 또는 전방 선언(forward declaration)으로 완화할 수 있습니다.

우리 컴파일러는 여전히 원 튜토리얼의 “문법 지시 번역(syntax directed translation)” 접근을 따릅니다.
즉, 파서는 파싱을 진행하면서 바로 코드를 출력합니다. 하지만 이 수준의 복잡도에서는, 단계를 분리하는 편이 더 낫다는 생각이 들기 시작합니다.
최소한 파서는 AST를 만들고, 별도의 단계가 AST로부터 코드를 출력하는 구조가 더 적절할 것입니다.

현재 구조에서는 앞을 알 수 없기 때문에 타이트한(tight) 코드를 출력하기가 어렵습니다.
출력을 하지 않고 미리 들여다보거나(back-patching 같은) 어떤 형태의 수정 작업 없이 “그냥” 진행하기가 어렵기 때문입니다.
예를 들어 호출 인자를 출력할 때, 각 ref 인자마다 스택에 별도의 공간을 따로 만들어야 합니다.
인자 개수를 미리 세어 한 번에 스택 증가 코드를 출력하기가 어려운데, 인자 파싱 과정 자체가 그 인자에 대한 코드 출력도 포함하기 때문입니다.

이것은 컴파일러 구성에서 흥미로운 교훈입니다. 문법 지시 번역은 단순한 언어에서는 결과를 빠르게 볼 수 있어 시작하기 아주 좋습니다.
하지만 입력 언어의 복잡도가 커질수록 이 방식은 걸림돌이 되고, 더 진보된 계층형(레이어드) 컴파일러 아키텍처로 전환하는 것이 가치가 있습니다.

## Part 14: Types

이 파트에서 원 튜토리얼은 매우 단순한 파서로 되돌아갑니다. 코드 생성이 거의 없고, 단일 문자 토큰, 프로시저 없음, 제어 흐름 없음 등입니다.

여느 때처럼 우리는 *그 정도로* 미니멀하게 하지는 않겠지만, 복잡도를 관리하기 위해 프로시저와 호출을 제거하긴 했습니다.

이 파트의 우리 컴파일러가 지원하는 프로그램 예시는 다음과 같습니다:

```
var long A=5, B=15;
var quad C=20;
var quad X=0;

program testprog
begin
    X = A + B + C;
end
.
```

타입이 지정된 변수 선언에 주목하세요. 2025년이므로 32비트/64비트 타입을 지원합니다
(원 튜토리얼의 8/16/32비트 대신). 또한 이는 WASM 타깃과도 더 잘 맞습니다(WASM은 기본 정수 타입으로 32비트/64비트만 지원합니다).

이전 파트에서 문법 지시 번역 접근이 복잡도가 커질수록 한계에 부딪힌다고 썼는데, 타입을 처리할 때는 그 점이 더 분명합니다.
첫째, 이제 모든 컴파일러 메서드는 파싱하고 출력한 표현식의 타입을 반환해야 합니다.
둘째, 파싱과 출력이 동시에 일어나기 때문에 때로는 그것만으로 충분하지 않습니다.
이항 연산의 양쪽을 출력한 뒤 타입이 맞지 않아 변환이 필요하다는 사실을 발견하면,
이미 출력된 값을 올바른 타입으로 바꾸기 위해 어색한 “스택 춤”을 춰야 합니다(우리 컴파일러의 `type_matched_binop` 참고).

정상적인 컴파일러라면 별도의 타입 체크 단계가 있어, 모든 AST 노드에 타입이 붙습니다.
그 다음 코드 생성기가 실행될 때는, 나중에 고쳐 끼울 필요 없이 처음부터 올바른 코드를 바로 출력할 수 있습니다.

## Part 15: Back to the Future

원 튜토리얼의 이 파트에는 새 코드가 없습니다. 저자는 기존 코드를 별도의 Pascal 유닛으로 분리하는 방식으로 구조를 재정리합니다.

## Part 16: Unit Construction

여기에도 새 코드는 없습니다. 저자는 기존에 존재하던 파서 코드를 계속 재구성하고 다시 작성해, 별도 유닛으로 조금 더 깔끔한 구조를 만듭니다.


